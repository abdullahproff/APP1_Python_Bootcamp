# Заметки по заданиям пятого дня бассейна Python

# Ex00

### **1. Требования к выполнению задания:**

1. **Программа не должна вызывать ошибки на корректном вводе**
    - Если программа падает на валидном запросе, задание будет оценено в **0 баллов**.
2. **Разработка WSGI-сервера без внешних зависимостей**
    - Нужно создать HTTP-сервер, который работает на **локальном порту 8888**.
    - В коде **нельзя использовать сторонние библиотеки** (например, Flask, FastAPI и т. д.).
    - Разрешено использовать стандартную библиотеку Python, включая `wsgiref.simple_server` и `urllib.parse`.
3. **Парсинг GET-параметра `species` из запроса**
    - Сервер должен получать вид (`species`) из URL-запроса и находить соответствующее имя (`credentials`).
    - Если вид известен — вернуть JSON с именем.
    - Если вид неизвестен — вернуть `{"credentials": "Unknown"}` и **HTTP статус 404**.
4. **Корректный формат ответа**
    - Ответ должен быть в **JSON-формате** с **заголовком `Content-Type: application/json`**.
    - Кодировка — **UTF-8**.
5. **Тестирование** *(необязательно, но рекомендуется)*
    - Можно написать тесты внутри `credentials.py`, которые выполняются при запуске `python credentials.py`.
    - Например, использовать `curl` для проверки работы сервера.
6. **Оформление проекта**
    - В репозиторий должны быть загружены файлы:
        - `credentials.py` (основной код сервера)
        - `requirements.txt` (может быть пустым, так как нет зависимостей)
        - `README.md` (инструкция по установке и запуску)

---

### **2. Что должно быть сделано по итогу?**

✅ **Готовый WSGI-сервер**, который:

- Слушает порт `8888`.
- Принимает GET-запросы с параметром `species`.
- Возвращает корректный JSON-ответ в зависимости от вида.
- Обрабатывает неизвестные виды с `404 Not Found`.

### **3. Основные концепции, затронутые в задании**

1. **WSGI (Web Server Gateway Interface)**
    - Это стандарт взаимодействия между веб-сервером и Python-приложением.
    - Позволяет создавать веб-приложения без фреймворков (например, Flask).
    - Мы используем `wsgiref.simple_server`, чтобы запустить простой HTTP-сервер.
2. **Обработка HTTP-запросов**
    - Клиент (например, браузер или `curl`) отправляет запрос на сервер.
    - Наш сервер получает параметры из URL (`species=Time%20Lord`), обрабатывает их и отвечает JSON-данными.
3. **Парсинг GET-параметров**
    - Вся информация передается через строку запроса (`?species=Time%20Lord`).
    - Мы используем `urllib.parse.parse_qs()`, чтобы разобрать эти параметры.
4. **Формирование HTTP-ответов**
    - Ответ состоит из:
        - **Статуса** (`200 OK` или `404 Not Found`).
        - **Заголовков** (например, `Content-Type: application/json`).
        - **Тела ответа** (JSON с результатом).
5. **JSON (JavaScript Object Notation)**
    - Формат передачи данных, понятный для людей и машин.
    - Мы используем `json.dumps()`, чтобы создать JSON-ответ.
6. **Запуск локального сервера**
    - `make_server('', 8888, application).serve_forever()` запускает сервер, который слушает **порт 8888** и принимает запросы.

### **Зачем это нужно?**

- Позволяет понять, как работают **веб-серверы**.
- Учимся **обрабатывать HTTP-запросы** вручную.
- Получаем опыт работы с **WSGI и JSON**, что полезно в веб-разработке и API.

### 4. Инструкции по запуску

1. **Создайте виртуальное окружение (рекомендуется, но не обязательно):**
    
    ```bash
    python3 -m venv venv
    source venv/bin/activate  # Для macOS/Linux
    
    venv\Scripts\activate  # Для Windows
    ```
    
2. **Создайте файл `requirements.txt`**
    
    Этот проект не требует внешних зависимостей, поэтому он остается пустым.
    
3. **Запустите сервер:**
    
    ```bash
    python3 credentials.py
    ```
    
4. **Проверьте работу с помощью `curl`:**
    
    ```bash
    curl "http://127.0.0.1:8888/?species=Time%20Lord"
    ```
    
    Ожидаемый ответ:
    
    ```json
    {"credentials": "Rassilon"}
    ```
    
5. **Остановка сервера:**
    
    Для остановки сервера используйте `Ctrl+C`.
    

### **5. Принцип работы скрипта `credentials.py`**

1. **Запуск WSGI-сервера**
    - Когда мы запускаем `python3 credentials.py`, создается веб-сервер, который **слушает порт 8888**.
    - Сервер использует стандартную библиотеку `wsgiref.simple_server`.
2. **Обработка запроса**
    - Когда клиент (браузер или `curl`) делает GET-запрос, например:
        
        ```perl
        http://127.0.0.1:8888/?species=Time%20Lord
        ```
        
    - Сервер получает параметр `species=Time%20Lord` и передает его в обработчик `application()`.
3. **Парсинг параметров**
    - `parse_qs(environ.get('QUERY_STRING', ''))` разбирает строку запроса и извлекает параметр `species`.
    - Проверяется, есть ли переданное значение в **словаре соответствий видов**.
4. **Формирование ответа**
    - Если вид найден, сервер отправляет JSON-ответ с **кодом 200 OK**:
        
        ```json
        {"credentials": "Rassilon"}
        ```
        
    - Если вид неизвестен, сервер отвечает **кодом 404 Not Found**:
        
        ```json
        {"credentials": "Unknown"}
        ```
        
5. **Передача ответа клиенту**
    - Устанавливаются заголовки:
        - `Content-Type: application/json` (чтобы клиент понимал, что это JSON).
        - `Content-Length` (размер ответа в байтах).
    - Ответ кодируется в `UTF-8` и отправляется клиенту.
    
    ### **Какие параметры можно передавать?**
    
    Ты можешь передать любой вид (`species`), например:
    
    ✅ **Корректные запросы:**
    
    ```bash
    curl "http://127.0.0.1:8888/?species=Sontaran"
    ```
    
    Ответ:
    
    ```json
    {"credentials": "General Staal"}
    ```
    
    ❌ **Неизвестный вид:**
    
    ```bash
    curl "http://127.0.0.1:8888/?species=Alien"
    ```
    
    Ответ:
    
    ```json
    {"credentials": "Unknown"}
    ```
    
    (и статус **404 Not Found**).
    
    ---
    
    ### **6. Что такое "словарь соответствий видов"?**
    
    Это просто **Python-словарь (`dict`)**, в котором каждому виду (`species`) соответствует "credentials" — важное имя, связанное с этим видом.
    
    Пример:
    
    ```python
    species_dict = {
        "Cyberman": "John Lumic",
        "Dalek": "Davros",
        "Human": "Leonardo da Vinci",
        "Time Lord": "Rassilon"
    }
    ```
    
    - Если мы запрашиваем `"species=Dalek"`, то из словаря берется `Davros`.
    - Если `"species=Unknown"`, то сервер отвечает `"Unknown"`.
    
    ---
    
    ### **Вывод:**
    
    - **Этот скрипт — простой HTTP-сервер**, который принимает GET-запросы и возвращает JSON-ответ.
    - **Ты можешь проверить его браузером, `curl` или тестовым Python-кодом.**
    - **Словарь соответствий видов** нужен, чтобы быстро находить правильное имя для каждого вида.

# Ex01

### 1. Требования к заданию

Задание **"Screwdriver Song"** заключается в создании клиент-серверного приложения для управления звуковыми файлами. Основные требования:

- **Серверная часть**:
    - Веб-интерфейс должен работать на порту 8888.
    - На главной странице должен отображаться список загруженных аудиофайлов и форма для загрузки новых файлов.
    - Сервер должен проверять MIME-тип загружаемых файлов и принимать только аудиофайлы (mp3, wav, ogg).
    - Если загружен файл неподдерживаемого формата, сервер должен отклонить его и вывести сообщение об ошибке.
- **Клиентская часть**:
    - Консольное приложение должно поддерживать две команды:
        - `upload /path/to/file.mp3` — загрузить аудиофайл на сервер.
        - `list` — получить и вывести список загруженных файлов.
    - Все взаимодействие между клиентом и сервером должно происходить через HTTP.

### 2. Пояснения к работе кода с итоговым решением

### Серверная часть (`server.py`)

- **Главная страница (`/`)**:
    - Отображает список загруженных файлов и форму для загрузки новых файлов.
    - Использует шаблон `index.html` для рендеринга HTML-страницы.
- **Загрузка файла (`/upload`)**:
    - Принимает файл от клиента, проверяет его расширение и сохраняет в папку `uploads`, если файл допустимого формата.
    - Возвращает текстовый ответ с сообщением об успешной загрузке или ошибке.
- **Список файлов (`/files`)**:
    - Возвращает список загруженных файлов в формате JSON.

### Клиентская часть (`screwdriver.py`)

- **Загрузка файла**:
    - Отправляет файл на сервер через POST-запрос и выводит ответ сервера.
- **Получение списка файлов**:
    - Делает GET-запрос к серверу и выводит список загруженных файлов.

### Веб-интерфейс (`templates/index.html`)

- **Форма загрузки файла**:
    - Позволяет пользователю выбрать файл и отправить его на сервер.
    - Использует JavaScript (Fetch API) для отправки файла без перезагрузки страницы.
- **Отображение сообщений**:
    - Сообщения об успешной загрузке или ошибке отображаются на странице.

---

### 3. Инструкции по запуску

1. **Установите зависимости**:
    - Создайте файл `requirements.txt`:
        
        ```
        Flask==2.3.2
        requests==2.31.0
        ```
        
    
    ```bash
    pip install -r requirements.txt
    ```
    

  **2. Активируйте виртуальную среду:**

```bash
python3 -m venv venv
source venv/bin/activate  # Для macOS/Linux

venv\Scripts\activate  # Для Windows
```

1. **Запустите сервер**:
    - Перейдите в директорию с проектом и выполните:
        
        ```bash
        python server.py
        ```
        
    - Сервер запустится на `http://localhost:8888`.
2. **Используйте клиентскую часть**:
    - Для загрузки файла:
        
        ```bash
        python screwdriver.py upload /path/to/file.mp3
        ```
        
    - Для получения списка файлов:
        
        ```bash
        python screwdriver.py list
        ```
        
3. **Откройте веб-интерфейс**:
    - Перейдите по адресу `http://localhost:8888` в браузере.
    - Вы увидите список загруженных файлов и форму для загрузки новых.

---

### 4. Использованные инструменты, библиотеки, функции

### Инструменты и библиотеки

- **Flask**:
    - Микрофреймворк для создания веб-приложений на Python.
    - Используется для реализации серверной части.
- **Requests**:
    - Библиотека для выполнения HTTP-запросов.
    - Используется в клиентской части для взаимодействия с сервером.
- **JavaScript (Fetch API)**:
    - Используется в веб-интерфейсе для отправки файлов на сервер без перезагрузки страницы.

### Основные функции

- **`allowed_file(filename)`**:
    - Проверяет, имеет ли файл допустимое расширение.
- **`upload_file()`**:
    - Обрабатывает загрузку файла на сервер.
- **`list_files()`**:
    - Возвращает список загруженных файлов.

---

### 5. Суть взаимодействия с веб-страницей и сервером

### Взаимодействие через веб-интерфейс

1. **Пользователь открывает веб-страницу**:
    - Сервер возвращает HTML-страницу с формой для загрузки файлов и списком загруженных файлов.
2. **Пользователь загружает файл**:
    - Файл отправляется на сервер через AJAX (Fetch API).
    - Сервер проверяет файл и возвращает текстовый ответ (успех или ошибка).
    - Ответ отображается на странице без перезагрузки.
3. **Список файлов обновляется**:
    - После успешной загрузки файла список файлов обновляется автоматически.

### Взаимодействие через клиентскую часть

1. **Загрузка файла**:
    - Клиент отправляет файл на сервер через POST-запрос.
    - Сервер возвращает текстовый ответ, который выводится в консоли.
2. **Получение списка файлов**:
    - Клиент делает GET-запрос к серверу и выводит список файлов в консоли.

---

### Итог

- **Серверная часть** реализована на Flask и предоставляет веб-интерфейс для загрузки и отображения файлов.
- **Клиентская часть** позволяет загружать файлы и получать список файлов через командную строку.
- **Веб-интерфейс** использует JavaScript для отправки файлов без перезагрузки страницы.
- **Взаимодействие** между клиентом и сервером происходит через HTTP-запросы.

### **Создайте виртуальное окружение:**

# Ex02

### Суть задания

У вас есть **5 Докторов** (Doctor 9, Doctor 10, Doctor 11, Doctor 12, Doctor 13). Каждый Доктор держит **одну sonic screwdriver (звуковую отвертку)**. Чтобы выполнить действие ("BLAST!"), каждому Доктору нужно **две отвертки** (одна у него уже есть, вторую он должен взять у соседа).

Проблема в том, что если все Докторы одновременно попытаются взять вторую отвертку, они могут **заблокировать друг друга**. Это классическая проблема параллельного программирования, похожая на "Проблему обедающих философов".

### Что нужно сделать?

1. **Создать Докторов и отвертки**:
    - Каждый Доктор — это отдельный поток.
    - Каждая отвертка — это ресурс, который может быть занят только одним Доктором одновременно.
2. **Синхронизировать Докторов**:
    - Нужно сделать так, чтобы Докторы могли брать две отвертки, не блокируя друг друга.
    - Если Доктор взял две отвертки, он выполняет действие ("BLAST!"), а затем отпускает отвертки.
3. **Вывести результат**:
    - Каждый Доктор должен вывести сообщение "Doctor X: BLAST!".
    - Порядок сообщений может быть разным при каждом запуске, так как потоки работают параллельно.

### Аналогия

Представьте, что у вас есть **5 человек за столом**, и перед каждым лежит **одна вилка**. Чтобы поесть, каждому нужно **две вилки** (одна своя, вторая — соседа). Если все одновременно попытаются взять вторую вилку, они могут **заблокировать друг друга** (никто не сможет поесть). Ваша задача — организовать процесс так, чтобы все могли поесть, не блокируя друг друга.

### Как это работает в коде?

1. **Класс `Screwdriver`**:
    - Это просто "отвертка". У неё есть `id` (номер) и `lock` (замок), который гарантирует, что только один Доктор может держать её одновременно.
2. **Класс `Doctor`**:
    - Это поток (thread), который представляет Доктора.
    - У каждого Доктора есть:
        - `id` (номер, например, 9, 10, 11 и т.д.),
        - `left_screwdriver` (левая отвертка),
        - `right_screwdriver` (правая отвертка).
    - Доктор пытается взять обе отвертки, выполнить "BLAST!", а затем отпустить их.
3. **Синхронизация**:
    - Чтобы Докторы не блокировали друг друга, используется `lock` (замок) для каждой отвертки.
    - Доктор сначала берёт левую отвертку, потом правую. Если обе свободны, он выполняет действие.
4. **Запуск потоков**:
    - Создаются 5 Докторов, каждый из которых работает в своём потоке.
    - Потоки запускаются одновременно, и Докторы начинают конкурировать за отвертки.

Порядок вывода может быть разным при каждом запуске, так как потоки работают параллельно.

# Итоговые навыки и технологии

| **Категория** | **Навыки** | **Технологии** |
| --- | --- | --- |
| Веб-разработка | Создание веб-сервера, обработка HTTP-запросов, работа с маршрутами | Flask, Jinja2, HTTP-протокол |
| Работа с файлами | Сохранение файлов, проверка расширений, управление файловой системой | `os`, `werkzeug.utils.secure_filename` |
| Клиент-серверное взаимодействие | Отправка и получение данных через HTTP, RESTful API | `requests`, Fetch API |
| Веб-интерфейс | Создание интерактивных страниц, работа с формами, AJAX | HTML, JavaScript, Fetch API |
| Обработка ошибок | Валидация данных, возврат HTTP-кодов состояния | Условные операторы, исключения, HTTP-коды (200, 400) |
| JSON | Сериализация и десериализация данных | `json` (Python), `response.json()` (JavaScript) |
| Командная строка | Создание CLI-приложений, обработка аргументов | `sys` |
| Тестирование и отладка | Тестирование кода, отладка через логи и инструменты разработчика | `print`, `console.log`, DevTools |