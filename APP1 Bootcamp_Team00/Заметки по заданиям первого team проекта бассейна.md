# Заметки по заданиям первого team проекта бассейна Python

# Ex00

### Суть задания

В этом задании вам нужно написать скрипт на Python, который будет скачивать страницы из Википедии и строить граф связей между статьями. Основная цель — сохранить граф в формате JSON, где вершины — это статьи, а направленные рёбра — ссылки между статьями. Скрипт должен уметь:

1. Начинать с определённой статьи (по умолчанию или заданной пользователем).
2. Переходить по ссылкам внутри статей, углубляясь на определённое количество уровней (по умолчанию 3).
3. Останавливаться, если количество статей превышает 1000 или меньше 20.
4. Логировать процесс сбора данных с помощью модуля `logging`.
5. Сохранять граф в JSON-файл.

### Основные концепции

1. **Парсинг HTML**: Для извлечения ссылок из статей Википедии.
2. **Графы**: Представление статей как вершин и ссылок как рёбер.
3. **Рекурсия/Итерация**: Для обхода ссылок на заданную глубину.
4. **Логирование**: Для отслеживания процесса выполнения скрипта.
5. **Аргументы командной строки**: Для настройки начальной статьи и глубины обхода.

### Пояснения к коду

1. **Логирование**: Используется модуль `logging` для вывода информации о процессе выполнения.
2. **Парсинг HTML**: Используется библиотека `BeautifulSoup` для извлечения ссылок из HTML-кода страницы.
3. **Обход ссылок**: Реализован с помощью BFS (поиск в ширину), чтобы контролировать глубину обхода.
4. **Сохранение графа**: Граф сохраняется в JSON-файл, где ключи — это URL страниц, а значения — списки ссылок.
5. **Аргументы командной строки**: Используется модуль `argparse` для настройки начальной страницы и глубины обхода.

### Запуск скрипта

### 1. **Используйте виртуальное окружение**

Создание виртуального окружения изолирует установленные пакеты от системных библиотек, что является безопасным и стандартным методом.

```bash
# Создать виртуальное окружение
python3 -m venv myenv

# Активировать виртуальное окружение
source myenv/bin/activate

# Установить пакеты внутри виртуального окружения
pip3 install -r requirements.txt
```

После активации виртуального окружения (команда `source myenv/bin/activate`), все установленные пакеты будут изолированы и не повлияют на системный Python.

Чтобы выйти из виртуального окружения:

```bash
deactivate
```

```
python cache_wiki.py -p 'https://en.wikipedia.org/wiki/Erdős_number' -d 3
```

Этот скрипт начнёт с указанной страницы и пройдёт по ссылкам на глубину 3 уровня, сохранив граф в файл `wiki.json`.

### **Почему граф выглядит как список ссылок, а не как граф?**

Граф — это математическая структура, состоящая из **узлов (вершин)** и **ребёр (связей между узлами)**. В JSON формате граф часто представляется как словарь, где:

- Ключи — это узлы (например, статьи Википедии).
- Значения — это списки узлов, на которые есть ссылки (т.е. куда "ведут" связи).

### **Что такое поиск в ширину?**

Поиск в ширину (BFS, Breadth-First Search) — это алгоритм обхода графа, который проходит его **по уровням**.

### Как это работает:

1. Начинаем с одной вершины (например, стартовой статьи Википедии).
2. Сначала посещаем **все соседние вершины** (т.е. статьи, на которые она ссылается).
3. Затем переходим к соседям соседей, и так далее, пока не достигнем заданной глубины или не закончатся вершины.

### **Поиск в глубину (Depth-First Search, DFS)**

это алгоритм обхода или поиска в графах и деревьях. Он исследует граф, двигаясь как можно "глубже" по одной ветви, пока не достигнет конечного узла (листа), после чего возвращается назад (происходит **откат**) и исследует другие ветви.

**Основные концепции DFS**

1. **Рекурсия или стек:**
    - DFS может быть реализован с использованием **рекурсии** (функция вызывает саму себя) или **стека** (вручную управляемая структура данных).
2. **Правило обхода:**
    - Алгоритм выбирает первый доступный узел и продолжает движение вглубь, пока не достигнет узла без непосещённых соседей.
3. **Откат (backtracking):**
    - Когда алгоритм достигает конечного узла, он возвращается к предыдущему узлу и исследует другие пути.
4. **Посещённые узлы:**
    - Чтобы избежать повторного посещения узлов, используется структура данных (например, множество или список) для хранения уже посещённых узлов.

### Пример (граф Википедии):

- **Стартовая статья:** "Erdős number".
- **Первый уровень:** Список всех статей, на которые ссылается "Erdős number".
- **Второй уровень:** Список всех статей, на которые ссылаются статьи из первого уровня.
- И так далее...

Этот подход позволяет исследовать граф постепенно, начиная от исходной точки.

### **Что значит углубляться на определённое количество уровней?**

Это связано с глубиной поиска в ширину (или глубину). В контексте задачи это означает:

- **Глубина 1:** Собираем только прямые ссылки со стартовой статьи.
- **Глубина 2:** Собираем ссылки со стартовой статьи **и все ссылки на статьи, найденные на первом уровне**.
- **Глубина 3 (по умолчанию):** То же самое, но добавляем ещё и ссылки на статьи, найденные на втором уровне.

### Пример (глубина 3):

1. Стартовая статья: "Erdős number".
2. Первый уровень: статьи, упомянутые в "Erdős number", например, "Graph theory", "Mathematics".
3. Второй уровень: статьи, упомянутые в "Graph theory" и "Mathematics".
4. Третий уровень: статьи, упомянутые в статьях второго уровня.

> Почему это важно?
Если не ограничить глубину, программа может обрабатывать слишком много данных (например, вся Википедия!), что займет много времени и ресурсов.
> 

### Основные концепции Neo4J

1. **Узлы (Nodes):**
    - Узел представляет объект или сущность (например, статью, человека, место).
    - Узлы могут иметь свойства (ключ-значение), например:
        
        ```
        
        CREATE (n:Article {title: "Erdős number", views: 5000})
        ```
        
2. **Связи (Relationships):**
    - Связи показывают, как узлы связаны друг с другом.
    - Они могут иметь тип и свойства. Например:Здесь `a` связан с `b` через связь `LINKS_TO`, имеющую свойство `weight`.
        
        ```
        CREATE (a)-[:LINKS_TO {weight: 1}]->(b)
        ```
        
3. **Метки (Labels):**
    - Узлы могут быть классифицированы по меткам (например, `Article`, `Person`, `Location`):
        
        ```
        CREATE (n:Person {name: "Paul Erdős"})
        ```
        
4. **Свойства (Properties):**
    - Узлы и связи могут иметь свойства в формате ключ-значение:
        
        ```
        CREATE (n:Article {title: "Erdős number", views: 10000})
        ```
        
5. **Cypher — язык запросов:**
    - Для работы с Neo4J используется язык Cypher, напоминающий SQL. Он позволяет создавать, читать, обновлять и удалять узлы и связи. Примеры:
        - Найти узел:
            
            ```
            MATCH (n:Article {title: "Erdős number"}) RETURN n
            ```
            
        - Создать узел:
            
            ```
            CREATE (n:Article {title: "Graph theory"})
            ```
            
        - Установить связь:
            
            ```
            MATCH (a:Article {title: "Erdős number"}), (b:Article {title: "Graph theory"})
            CREATE (a)-[:LINKS_TO]->(b)
            ```
            

---

### Преимущества Neo4J

1. **Быстрая работа с графами:**
    - В отличие от SQL-баз, Neo4J оптимизирован для графовых структур, что делает запросы по графам (например, поиск пути) более быстрыми.
2. **Интуитивная структура данных:**
    - Данные хранятся в графовом виде, что соответствует реальному представлению многих задач (социальные сети, ссылки на статьи, логистика и т.д.).
3. **Широкая экосистема:**
    - Neo4J поддерживает интеграцию с Python, Java, JavaScript и другими языками.
    - Поддерживает библиотеки, такие как `neo4j` (Python) для взаимодействия с базой.
4. **Масштабируемость:**
    - Подходит как для небольших, так и для крупных графов с миллионами узлов и связей.
5. **Инструменты визуализации:**
    - Neo4J предоставляет встроенный интерфейс (Neo4J Browser) для визуализации графов и выполнения запросов.

---

# Ex01

### Описание задания

Задание заключается в написании программы `shortest_path.py`, которая находит кратчайший путь между двумя страницами в сериализованной базе данных (графе). Программа должна учитывать два режима работы:

1. **Направленный граф** (по умолчанию): ребра графа направленные, и путь можно пройти только в одном направлении.
2. **Ненаправленный граф** (с флагом `-non-directed`): ребра графа двунаправленные, и путь можно пройти в любом направлении.

Программа должна принимать на вход два аргумента:

- `-from`: начальная страница.
- `-to`: конечная страница.

Дополнительные параметры:

- `-non-directed`: указывает, что граф ненаправленный.
- `v`: включает вывод пути в лог.

Если путь не найден, программа должна вывести `'path not found'`. Если файл базы данных не найден, программа должна вывести `'database not found'`.

### Концепции и инструменты

1. **Графы**: Задание связано с поиском кратчайшего пути в графе. Граф может быть направленным или ненаправленным.
2. **Алгоритм поиска в ширину (BFS)**: Этот алгоритм используется для поиска кратчайшего пути в невзвешенном графе.
3. **Аргументы командной строки**: Программа должна обрабатывать аргументы командной строки, такие как `-from`, `-to`, `-non-directed`, и `v`.
4. **Логирование**: Программа должна поддерживать вывод пути в лог при использовании флага `v`.
5. **Работа с файлами**: Программа должна читать граф из файла, путь к которому задается через переменную окружения `WIKI_FILE`.

### Инструкция по запуску

1. **Установите переменную окружения**: Установите переменную окружения `WIKI_FILE`, указывающую на ваш файл базы данных:
    
    ```
    export WIKI_FILE=wiki.txt
    ```
    
2. **Запустите программу**: Запустите программу с нужными аргументами:
    
    ```
    python shortest_path.py --from 'Welsh Corgi' --to 'Solomon' -v
    ```
    
    или
    
    ```
    python shortest_path.py --from 'Solomon' --to 'Welsh Corgi' --non-directed -v
    ```
    

### Пример вывода

При запуске команды:

```
python shortest_path.py --from 'Welsh Corgi' --to 'Solomon' -v
```

Вывод будет:

```
Welsh Corgi -> Dog training -> King Solomon's Ring (book) -> Solomon
3
```

Если путь не найден, программа выведет:

```
path not found
```

Если файл базы данных не найден, программа выведет:

```
database not found
```

### **Переменные окружения**

Переменная окружения (environment variable) — это динамическое значение, которое может быть использовано программами и операционной системой для настройки поведения приложения. В контексте Python переменные окружения могут быть использованы для управления конфигурацией приложений, хранения секретов (например, паролей или ключей API), указания путей к файлам и другим важным параметрам.

### **Зачем нужны переменные окружения?**

1. **Безопасность** : Переменные окружения позволяют хранить конфиденциальные данные, такие как пароли и ключи API, вне исходного кода программы.
2. **Гибкость** : Конфигурация приложения может быть изменена без изменения самого кода. Это особенно полезно в различных средах (разработка, тестирование, продакшн).
3. **Портативность** : Программы могут легко переноситься между различными системами и средами, так как все необходимые параметры задаются через переменные окружения.

# Ex02

### Описание задания

Задание заключается в визуализации графа, где узлы представляют собой страницы, а ребра — связи между ними. Размер узла должен соответствовать количеству входящих связей (чем больше связей, тем больше узел). Это позволяет визуально определить наиболее популярные (или "великие") страницы в наборе данных.

### Концепции и инструменты

1. **Графы**: Граф — это структура данных, состоящая из узлов (вершин) и ребер (связей между узлами). В данном случае узлы представляют страницы, а ребра — связи между ними.
2. **Визуализация данных**: Используются библиотеки для визуализации графов, такие как `networkx` для создания графа и `matplotlib` для его отображения в виде PNG-изображения. Для интерактивной визуализации можно использовать библиотеки `Altair` или `Bokeh`.
3. **Чтение данных из файла**: Данные о графе считываются из файла, который был сгенерирован в предыдущем задании (EX00).
4. **Обработка окружения**: Используется переменная окружения `WIKI_FILE` для указания пути к файлу с данными.

### Инструкция по запуску

1. **Установка зависимостей**:
    
    Убедитесь, что у вас установлены необходимые библиотеки. Если нет, установите их с помощью pip:
    
    ```
    pip3 install networkx matplotlib pyvis
    pip3 install scipy
    
    или
    
    pip3 install -r requirements.txt
    ```
    
2. **Подготовка данных**:
    
    Убедитесь, что у вас есть файл с данными о графе, который был сгенерирован в задании EX00. Путь к этому файлу должен быть указан в переменной окружения `WIKI_FILE`.
    
3. **Запуск скрипта**:
    
    Установите переменную окружения и запустите скрипт:
    
    ```
    export WIKI_FILE=../Ex00/wiki.json
    python3 render_graph.py
    ```
    
4. **Результаты**:
    
    После выполнения скрипта в текущей директории появятся два файла:
    
    - `wiki_graph.png` — статическое изображение графа.
    - `wiki_graph.html` — интерактивная визуализация графа, которую можно открыть в браузере.

### Пояснение к коду

- **Чтение графа**: Функция `read_graph_from_file` читает данные из файла и строит ориентированный граф с помощью библиотеки `networkx`.
- **Визуализация в PNG**: Функция `render_graph_png` использует `matplotlib` для создания статического изображения графа. Размер узлов зависит от количества входящих связей.
- **Интерактивная визуализация**: Функция `render_graph_html` создает интерактивную HTML-страницу с использованием библиотеки `pyvis`.

Это решение позволяет визуализировать граф как в статическом, так и в интерактивном формате, что соответствует требованиям задания.