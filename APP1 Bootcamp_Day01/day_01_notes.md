# Заметки по заданиям второго дня бассейна Python

# Exercise 00

В этом задании нужно написать три функции, работающие с кошельком (`purse`) — словарем, который хранит содержимое в виде пар «ключ-значение», где ключ — строка, а значение — целое число. Например, в кошельке могут лежать «gold_ingots» с количеством 5, или «stones» с количеством 10.

Задание требует создать функции, которые будут манипулировать только «gold_ingots» (золотыми слитками), не затрагивая другие элементы словаря:

1. **`add_ingot(purse)`**: Эта функция должна добавить один золотой слиток в кошелек. Она возвращает новый словарь, увеличив количество «gold_ingots» на 1. Если в кошельке не было «gold_ingots», добавляется запись `{"gold_ingots": 1}`. Другие предметы в кошельке можно либо оставить, либо игнорировать.
2. **`get_ingot(purse)`**: Эта функция должна забрать один слиток из кошелька, если он там есть. Она также возвращает новый словарь: если «gold_ingots» изначально было 1, он удаляется из результата, если больше — уменьшается на 1. Если в кошельке не было слитков, возвращается новый словарь с тем же содержимым, что и оригинальный.
3. **`empty(purse)`**: Эта функция должна вернуть пустой словарь, вне зависимости от исходного содержания кошелька.

### Условия

- **Отсутствие побочных эффектов**: Функции не должны изменять исходный словарь, а должны возвращать новые объекты. Таким образом, любой объект, переданный в функцию, остается неизменным.
- **Работа с пустыми и произвольными кошельками**: Функции должны корректно работать, если в кошельке не было слитков или если в нем вообще нет никакого содержимого. Например, попытка забрать слиток из пустого кошелька не должна вызывать ошибку, просто возвращается пустой словарь или кошелек с текущим содержимым.
- **Фокус на золотых слитках**: Задание акцентирует внимание на «gold_ingots» — только с ними работают функции. Остальные предметы либо сохраняются, либо удаляются, по желанию.

В итоге, если выполнить композицию функций, как указано в примере `add_ingot(get_ingot(add_ingot(empty(purse))))`, получится `{"gold_ingots": 1}`, так как:

1. `empty(purse)` возвращает пустой словарь `{}`.
2. `add_ingot` добавляет слиток и возвращает `{"gold_ingots": 1}`.
3. `get_ingot` забирает один слиток и возвращает пустой словарь `{}`.
4. Еще один вызов `add_ingot` добавляет новый слиток, снова возвращая `{"gold_ingots": 1}`.

Таким образом, результат выполнения этой цепочки — `{ "gold_ingots": 1 }`.

**Словарь** (в программировании, особенно в языке Python) — это структура данных, которая хранит пары «ключ-значение». Каждой записи в словаре присвоен уникальный **ключ**, с помощью которого можно получить соответствующее **значение**.

### Как устроен словарь?

Словарь можно представить как ящик с разными отделениями, где у каждого отделения есть свой **ключ** — своеобразный "адрес". Когда вам нужно что-то найти, вы обращаетесь к ключу, и словарь выдает связанное с ним значение.

Например, словарь можно записать так:

```python
purse = {
    "gold_ingots": 3,
    "silver_coins": 10,
    "stones": 5
}
```

В этом примере:

- Ключ `"gold_ingots"` связан со значением `3`.
- Ключ `"silver_coins"` связан со значением `10`.
- Ключ `"stones"` связан со значением `5`.

### Основные особенности словаря:

- **Ключи должны быть уникальными**: в одном словаре не может быть двух одинаковых ключей.
- **Быстрый доступ по ключу**: если вы знаете ключ, то можете мгновенно получить значение, связанное с этим ключом.
- **Мутируемость**: можно добавлять новые элементы, изменять значения существующих элементов или удалять их.

### Примеры операций со словарем

1. **Получение значения по ключу**:
    
    ```python
    gold = purse["gold_ingots"]  # Вернет 3
    ```
    
2. **Добавление или изменение значения**:
    
    ```python
    purse["gold_ingots"] = 4  # Теперь "gold_ingots" будет 4
    ```
    
3. **Удаление элемента**:
    
    ```python
    del purse["stones"]  # Удаляет ключ "stones" и его значение
    ```
    
4. **Проверка наличия ключа**:
    
    ```python
    if "gold_ingots" in purse:
        print("Есть золотые слитки!")
    ```
    

Словари очень удобны, когда нужно хранить набор данных с конкретными идентификаторами, и поэтому они широко используются в программировании для работы с данными, особенно в приложениях, где данные имеют свойства или характеристики.

### Почему класс `PurseFields` — это перечисление?

```python
class PurseFields(str, Enum):
    GI = "gold_ingots"
```

1. **Наследование от `Enum`**:
    - В Python `Enum` — это специальный класс, который используется для создания **перечислений**. Перечисления позволяют задавать набор символических имен, которые соответствуют некоторым значениям.
    - Когда мы пишем `class PurseFields(str, Enum):`, мы наследуем класс `PurseFields` от `Enum`. Это автоматически делает `PurseFields` перечислением, что означает:
        - Он может использоваться для создания именованных значений (в данном случае — для создания ключа `GI` для `"gold_ingots"`).
        - Все члены этого перечисления становятся **уникальными и именованными значениями**, а их можно сравнивать, перебирать и использовать как константы.
2. **Наследование от `str`**:
    - В дополнение к наследованию от `Enum`, класс `PurseFields` также наследует от `str`. Это означает, что члены перечисления будут строками.
    - Например, `PurseFields.GI` будет строкой, а не просто обычным значением типа `Enum`. Таким образом, элементы перечисления будут вести себя как строки и иметь все их свойства (например, можно выполнять операции строк).

### Пример работы с перечислением `PurseFields`:

- Мы можем получить доступ к значениям перечисления через атрибуты класса:

```python
print(PurseFields.GI)        # Выведет: PurseFields.GI
print(PurseFields.GI.value)  # Выведет: "gold_ingots"
```

- Перечисления в Python поддерживают сравнение и другие операции:

```python
if PurseFields.GI == "gold_ingots":
    print("It's a match!")  # Выведет: It's a match!
```

- Кроме того, с перечислениями можно работать, используя их методы:

```python
for field in PurseFields:
    print(field.name, field.value)
```

Этот цикл переберет все элементы перечисления и выведет их имя и значение.

### Ключевые признаки перечисления:

1. **Наследование от `Enum`** — основной индикатор, что класс является перечислением.
2. **Уникальные члены** — каждый элемент перечисления представляет собой уникальное значение. В вашем случае, `PurseFields.GI` будет являться уникальным значением `"gold_ingots"`.
3. **Методы и атрибуты перечисления** — перечисления позволяют легко работать с их значениями, сравнивать их, перебирать и получать дополнительную информацию о членах перечисления.

Итак, **класс `PurseFields` является перечислением, потому что он наследует от `Enum`**, и это добавляет в класс функциональность перечисления: он может хранить набор предопределенных значений с уникальными именами и значениями.

### Конструкция `if __name__ == "__main__"`

В Python существует специальная переменная `__name__`, которая указывает на имя текущего модуля (модуль — это просто Python-файл с расширением `.py`). Когда Python запускает файл, значение `__name__` для этого файла будет установлено в строку `"__main__"`. Если же файл импортируется как модуль в другой файл, то значение `__name__` будет равно имени этого модуля.

Конструкция `if __name__ == "__main__":` используется для того, чтобы разделить код, который должен выполняться при прямом запуске скрипта, и код, который должен быть доступен при импорте модуля в другие файлы. Эта конструкция предотвращает выполнение кода при импорте.

Пример:

```python
def print_hello():
    print("Hello from the function!")

if __name__ == "__main__":
    # Этот код выполнится только если скрипт запущен напрямую, а не импортирован
    print("This code runs only when the script is executed directly.")
    print_hello()
```

- **Когда вы запускаете файл напрямую (например, `python script.py`)**: выполняется код внутри `if __name__ == "__main__":`.
- **Когда файл импортируется как модуль**: код внутри этого блока не выполняется.

# Exercise 01

В этом задании необходимо создать функцию `split_booty`, которая будет принимать **любое количество кошельков** (словарей) в качестве аргументов, а затем возвращать **три новых кошелька**, в которых количество золотых слитков будет распределено так, чтобы разница между количеством слитков в любых двух кошельках не превышала 1.

- Нужно  обработать **несколько кошельков** (словарей), которые могут содержать различные предметы. Но вам нужно **игнорировать** все предметы, кроме золотых слитков, которые обозначены как `"gold_ingots"`.
- В итоге, из всех золотых слитков, которые содержатся в кошельках, нужно распределить их между тремя новыми кошельками. Разница в количестве золотых слитков между любыми двумя кошельками не должна превышать 1.
- Вы можете использовать функцию `.get()` для извлечения количества золотых слитков из каждого кошелька. Если в кошельке нет ключа `"gold_ingots"`, эта функция вернет 0 по умолчанию.
- Вы можете воспользоваться функцией из вашего первого задания, например, **add_ingot** и **empty**, для работы с кошельками.

### Итог:

Задача требует от вас:

- Собрать все золотые слитки из входных кошельков.
- Разделить их на 3 равные части.
- Раздать остаток равномерно между тремя кошельками.
- Вернуть 3 новых кошелька с этим разделением.

Важно использовать **функции из предыдущего задания**, которые вы уже написали (например, `add_ingot` и `get_ingot`), чтобы работать с кошельками и следовать принципам функционального программирования (не изменять входные данные, а создавать новые объекты).

### Что такое кортеж в языке Python и чем кортеж отличается от словаря?

**Кортеж (Tuple):**

- Кортеж в Python — это **неизменяемый** (immutable) контейнер, который может содержать несколько элементов. Элементы могут быть любого типа: строки, числа, другие контейнеры и т. д.
- Кортеж создается с использованием круглых скобок `()` и может содержать **неизменяемые** данные.
- Кортежи позволяют работать с набором данных, который не должен изменяться после создания.

Пример:

```python
my_tuple = (1, 2, 3)  # Кортеж с тремя целыми числами
```

**Отличия между кортежем и словарем:**

1. **Изменяемость (Mutability):**
    - Кортежи — неизменяемые (вы не можете изменить элементы после создания).
    - Словари — изменяемые (вы можете добавлять, удалять или изменять элементы).
2. **Типы данных (Content):**
    - Кортежи могут содержать любые типы данных (включая другие кортежи или списки), и каждый элемент имеет индекс (по которому можно обратиться).
    - Словарь — это набор пар **ключ-значение**. Ключи могут быть любыми неизменяемыми типами данных, а значения — любыми.
3. **Синтаксис:**
    - Кортеж создается с помощью круглых скобок `()`.
    - Словарь создается с помощью фигурных скобок `{}`, где пары ключ-значение разделены двоеточием.

Пример словаря:

```python
my_dict = {"key1": "value1", "key2": "value2"}  # Словарь с ключами и значениями
```

### 2. Цикл с переменной `divisor`

В цикле `for divisor in range(3, 0, -1):` переменная `divisor` принимает значения 3, 2 и 1 по следующей причине:

- **`range(3, 0, -1)`** — это функция Python, которая генерирует последовательность чисел с шагом -1.
    - **`3`** — начальное значение, с которого начинается последовательность.
    - **`0`** — конечное значение, до которого последовательность идет (но оно не включается).
    - **`1`** — шаг, который указывает, что числа будут уменьшаться.

Таким образом, `range(3, 0, -1)` создает последовательность чисел **3, 2, 1**, то есть три значения. Цикл будет выполняться три раза: первый раз с `divisor = 3`, второй — с `divisor = 2`, и третий — с `divisor = 1`.

Это делается для того, чтобы **разделить общее количество золотых слитков на 3, 2 и 1** в порядке убывания, начиная с 3, а затем равномерно распределить слитки по трем кошелькам.

### 3. Стандартная библиотека Python `argparse`

`argparse` — это стандартный модуль Python, используемый для обработки и парсинга аргументов командной строки. С его помощью можно легко создавать интерфейсы командной строки для ваших скриптов, позволяя передавать параметры и управлять их обработкой.

### Основные моменты о `argparse`:

1. **Импорт модуля**:
    
    ```python
    import argparse
    ```
    
2. **Создание парсера**:
Для начала необходимо создать объект `ArgumentParser`, который будет управлять парсингом аргументов.
    
    ```python
    parser = argparse.ArgumentParser(description="Описание вашей программы")
    ```
    
3. **Добавление аргументов**:
С помощью метода `add_argument()` вы можете добавить различные аргументы и опции, которые программа будет принимать.
    
    ```python
    parser.add_argument('filename', type=str, help='Имя файла для обработки')  
    # Позиционный аргумент
    parser.add_argument('-v', '--verbose', action='store_true', help='Включить подробный режим')  # Опциональный аргумент
    ```
    
    - **Позиционные аргументы** обязательны для передачи при запуске программы.
    - **Опциональные аргументы** начинаются с `` или `-` и могут быть необязательными. Они часто используются для флагов или параметров с настройками.
4. **Парсинг аргументов**:
После определения всех аргументов, необходимо вызвать метод `parse_args()` для получения их значений.
    
    ```python
    args = parser.parse_args(
    ```
    
    Значения аргументов можно использовать через объект `args`, обращаясь к ним по имени:
    
    ```python
    print(args.filename)
    if args.verbose:
        print("Подробный режим включен"
    ```
    
5. **Пример использования**:
Вот простой пример программы, принимающей файл и флаг:
    
    ```python
    import argparse
    
    parser = argparse.ArgumentParser(description="Пример программы с argparse")
    parser.add_argument('filename', type=str, help='Имя файла')
    parser.add_argument('-v', '--verbose', action='store_true', help='Включить подробный режим')
    
    args = parser.parse_args()
    
    print(f"Имя файла: {args.filename}")
    if args.verbose:
        print("Подробный режим включен")
    ```
    
    **Запуск программы в командной строке**:
    
    ```bash
    bash
    python script.py myfile.txt -v
    
    ```
    

### Основные параметры `add_argument()`:

- **`type`**: Указывает тип данных для аргумента (например, `int`, `float`, `str`).
- **`help`**: Описание аргумента для вывода в справке.
- **`default`**: Значение по умолчанию, если аргумент не был передан.
- **`nargs`**: Указывает количество аргументов (например, `?`, ``, `+`).
- **`choices`**: Ограничивает выбор определенными значениями.
- **`action`**: Определяет, как обрабатывается аргумент (например, `store`, `store_true`).

### Преимущества `argparse`:

- Легкость в использовании для создания интерфейсов командной строки.
- Автоматическое создание справки (`-help`).
- Возможность задавать значения по умолчанию и типы данных.

`argparse` делает обработку аргументов командной строки простой и интуитивно понятной, облегчая создание мощных и гибких скриптов.

# Exercise 02

В этом задании от вас требуется сделать так, чтобы при вызове функций `add_ingot(purse)`, `get_ingot(purse)` и `empty(purse)` печаталось сообщение `"SQUEAK"`. Однако, вы не можете изменить тела этих функций напрямую.

### Подсказка о "специальных декорациях"

В задании намекают на использование **декораторов**. Декораторы в Python — это специальные функции, которые позволяют добавлять дополнительное поведение к другим функциям без изменения их исходного кода

### 1. Как работают декораторы?

Декоратор — это функция, которая принимает другую функцию в качестве аргумента и возвращает новую функцию с дополнительным поведением. Например, чтобы при каждом вызове функции выводилось `"SQUEAK"`, можно создать декоратор:

```python
def squeak_decorator(func):
    def wrapper(*args, **kwargs):
        print("SQUEAK")
        return func(*args, **kwargs)
    return wrapper
```

### Применение декоратора к функциям

Чтобы применить декоратор к уже написанным функциям, можно использовать синтаксис `@decorator_name` перед их определением. Однако, так как вы не можете изменить тела функций, вы должны применить декоратор вручную при их импорте или вызове:

```python
python
Копировать код
import purse  # Импортируем ваш модуль с функциями

# Применяем декоратор к функциям
purse.add_ingot = squeak_decorator(purse.add_ingot)
purse.get_ingot = squeak_decorator(purse.get_ingot)
purse.empty = squeak_decorator(purse.empty)

# Теперь при вызове функций будет выводиться "SQUEAK"
purse.add_ingot({})
purse.get_ingot({})
purse.empty()

```

### Пояснение, что от вас требуется

1. Написать декоратор, который добавляет печать `"SQUEAK"` перед вызовом функции.
2. Применить этот декоратор к функциям `add_ingot`, `get_ingot` и `empty` без изменения их исходного кода.
3. Убедиться, что при вызове этих функций они выводят `"SQUEAK"` и выполняют свое основное поведение.

### 2. **Callable**

**Callable** — это объект, который можно вызвать как функцию. В Python, все функции и методы являются callable объектами, но также есть и другие объекты, которые можно сделать callable, например, классы с методом `__call__`.

**Пример:**

```python
def example_function():
    print("I am callable!")

print(callable(example_function))  # True, так как функция может быть вызвана.

# Класс с методом __call__, который делает его callable.
class ExampleClass:
    def __call__(self):
        print("I am also callable!")

example_instance = ExampleClass()
print(callable(example_instance))  # True
```

**Применение в коде задания:**
Аргумент `func` в декораторе `make_squeak` имеет тип `Callable`, указывая, что этот аргумент — функция, которую можно вызвать.

### 3. **wraps**

**`wraps`** — это декоратор из модуля `functools`, который помогает сохранять метаданные оригинальной функции при использовании пользовательских декораторов. Когда вы оборачиваете функцию с помощью декоратора, такие метаданные, как имя функции, документация и аннотации, могут быть потеряны. `@wraps` решает эту проблему.

**Пример:**

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print("Before function")
        result = func(*args, **kwargs)
        print("After function")
        return result
    return wrapper

@my_decorator
def hello():
    """This function says hello."""
    print("Hello, world!")

print(hello.__name__)  # Выведет "hello", благодаря @wraps, иначе было бы "wrapper".
print(hello.__doc__)   # Выведет "This function says hello."
```

- ***** используется для распаковки или сбора аргументов в **кортеж**.
- ** используется для распаковки или сбора аргументов в **словарь**.

### 4. **Метаданные**

**Метаданные** — это информация о данных. В контексте Python-функций метаданные включают:

- Имя функции (`__name__`)
- Документацию (`__doc__`)
- Аннотации аргументов и возвращаемого значения (`__annotations__`)

Эти метаданные помогают понять, что делает функция, и сохраняются с помощью `@wraps` в пользовательских декораторах.