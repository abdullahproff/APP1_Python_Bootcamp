import argparse # модуль, который является списком всех аргументов командной строки
import purse # Импортируем модуль `purse`

def split_booty( #объявление функции, которая принимает произвольное количество аргументов, каждый из которых является кошельком (PurseType).
    *purses: purse.PurseType, # Принимаем произвольное количество кошельков (purses), которые являются объектами типа PurseType.
) -> tuple[purse.PurseType, purse.PurseType, purse.PurseType]:# Функция возвращает кортеж из трех кошельков типа PurseType.

    total_ingots: int = 0 # Инициализируем переменную `total_ingots`, чтобы хранить общее количество золотых слитков.
    for purse_ in purses: # Проходим по каждому кошельку, переданному в аргументах функции.
        total_ingots += purse_.get(purse.PurseFields.GI, 0) # Извлекаем количество золотых слитков из каждого кошелька и добавляем к общему количеству.
        # Метод `get` извлекает значение по ключу PurseFields.GI (ключ для золотых слитков),
        # если ключ не найден, возвращается 0.

    purses_split = [] # Создаем пустой список `purses_split`, в котором будут храниться три новых кошелька.
    for divisor in range(3, 0, -1): # Цикл от 3 до 1 включительно (т.е. три итерации).
        part = total_ingots // divisor # Разделяем оставшееся количество золотых слитков на количество (divisor) и получаем целую часть от деления.
        purses_split.append({purse.PurseFields.GI.value: part}) # Создаем новый кошелек с полученным количеством золотых слитков и добавляем его в список.
        total_ingots -= part # Уменьшаем общее количество слитков на количество, которое мы только что распределили.
    
    return (
        purses_split[0], # Возвращаем кортеж с тремя новыми кошельками.
        purses_split[1],
        purses_split[2],
    )

# Включение проверки if __name__ == "__main__":
if __name__ == "__main__":
    #создается объект парсера командной строки, 
    # который будет использоваться для обработки аргументов, переданных в командной строке.
    parser = argparse.ArgumentParser(description="Split gold ingots into 3 purses.")
    #argparse.ArgumentParser() — это функция из стандартной библиотеки Python, 
    # которая создает объект парсера. Параметр description задает описание того, что делает этот скрипт.
    # Ожидаем, что будут переданы значения для золотых слитков
    parser.add_argument('purses', metavar='P', type=int, nargs='+', help="Gold ingots in each purse")
    # add_argument('purses', ...) — это метод, который говорит парсеру, 
    # что мы ожидаем получить аргумент с именем purses. 
    # Это будет список значений, которые пользователь передает при запуске программы.
    # Разбираем аргументы командной строки
    # metavar='P' — имя для аргумента в выводе справки, 
    # так что когда кто-то вызовет справку (например, python3 splitwise.py -h), 
    # он увидит, что ожидаются значения для purses.
    # type=int — это говорит парсеру, что каждый переданный аргумент должен быть целым числом.
    # nargs='+' — означает, что программа ожидает одно или несколько значений. 
    # Это означает, что пользователь может передать любое количество чисел (от одного и более).
    # help="Gold ingots in each purse" — описание, которое будет отображаться, 
    # если пользователь запрашивает справку о программе
    args = parser.parse_args()
    # Здесь вызывается метод parse_args(), 
    # который анализирует аргументы, переданные в командной строке, и сохраняет их в объект args. 
    # Например, если запускать программу с аргументами 5 3 10, то args.purses будет равно [5, 3, 10].

    # Преобразуем переданные значения в кошельки
    purses = [{purse.PurseFields.GI.value: ingots} for ingots in args.purses]
    # После того как аргументы разобраны, создается список purses, 
    # состоящий из словарей. Каждый элемент в args.purses (это количество слитков) 
    # преобразуется в кошелек в виде словаря, где ключом будет "gold_ingots", 
    # а значением количество слитков.
    # purse.PurseFields.GI.value — это доступ к строковому значению из перечисления PurseFields, 
    # которое будет использоваться как ключ для каждого кошелька.
    # далее перебираем все элементы в args.purses 
    # и для каждого числа (количества слитков) создаем новый словарь { "gold_ingots": ingots }.

    # Вызываем функцию split_booty и выводим результат
    result = split_booty(*purses)
    # Теперь, когда у нас есть кошельки, мы передаем их в функцию split_booty, 
    # которая разбивает все слитки на три части и возвращает три новых кошелька.
    # *purses — это синтаксис распаковки списка. 
    # Каждый элемент из списка purses передается как отдельный аргумент в функцию split_booty.
    # Функция split_booty возвращает кортеж из трех словарей, 
    # представляющих три кошелька с разбитыми слитками.
    
    print(result)
    # пример запуска: python splitwise.py 5 3 10
    #  если вы передаете 5 3 10, 
    # то программа разобьет все слитки между тремя кошельками, например:
    # ({'gold_ingots': 5}, {'gold_ingots': 5}, {'gold_ingots': 8})
    # где каждый кошелек будет содержать определенное количество слитков.
    # Скобки в выводе ({"gold_ingots": 5}, {"gold_ingots": 5}, {"gold_ingots": 8}) обозначают, 
    # что результат является кортежем.
    # { } указаывают на то, что {"gold_ingots": 5} — это отдельный словарь.
    # ({"gold_ingots": 5}, {"gold_ingots": 5}, {"gold_ingots": 8}) — это кортеж, содержащий три словаря.
    # Круглые скобки помогают визуально и синтаксически различать кортеж от других типов данных, например, списка [] или отдельного словаря {}.